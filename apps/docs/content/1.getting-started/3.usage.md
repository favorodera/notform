---
title: Usage
description: Learn the fundamentals of NotForm and create your first validated form.
navigation:
  icon: i-tabler-adjustments
---

:name-text makes form validation in Vue simple and intuitive. This guide will walk you through the basics of creating validated forms with :name-text.

## Your First Form

Let's start with a simple login form to understand the core concepts:

::code-collapse
```vue [LoginForm.vue]
<script setup lang="ts">
import { useNotForm, NotForm, NotField, NotMessage } from 'notform'
import { z } from 'zod'

const { state, id, submit } = useNotForm({
  schema: z.object({
    email: z.email('Please enter a valid email'),
    password: z.string().min(8, 'Password must be at least 8 characters')
  }),
  onSubmit: async (data) => {
    console.log('Form submitted:', data)
    // Handle your form submission here
  }
})
</script>

<template>
  <NotForm :id="id" @submit="submit">
    <NotField name="email" v-slot="{ methods, name }">
      <label :for="name">
        Email
        <input
          v-model="state.email"
          type="email"
          :id="name"
          :name="name"
          v-bind="methods"
        />
        <NotMessage :name="name" />
      </label>
    </NotField>

    <NotField name="password" v-slot="{ methods, name }">
      <label :for="name">
        Password
        <input
          v-model="state.password"
          type="password"
          :id="name"
          :name="name"
          v-bind="methods"
        />
        <NotMessage :name="name" />
      </label>
    </NotField>

    <button type="submit">Login</button>
  </NotForm>
</template>
```
::

That's it! You now have a fully validated form with error handling. Let's break down what's happening.

## Understanding the Components

### useNotForm Composable

The `useNotForm` composable is the core of :name-text. It sets up your form state, validation, and submission handling:

```ts
const { state, id, submit } = useNotForm({
  schema: z.object({
    email: z.email(),
    password: z.string().min(8)
  }),
  onSubmit: async (data) => {
    // This only runs if validation passes
    console.log('Validated data:', data)
  }
})
```

**What you get back:**
- `state` - Reactive form state (typed based on your schema)
- `id` - Unique form ID for accessibility
- `submit` - Submit handler that validates before calling your onSubmit and <!---[`more`](/api/use-not-form)-->

### NotForm Component

The `NotForm` component wraps your form fields and handles submission:

```vue
<NotForm :id="id" @submit="submit">
  <!-- Your fields go here -->
</NotForm>
```

### NotField Component

`NotField` is a renderless component that provides field-specific methods and state:

```vue
<NotField name="email" v-slot="{ methods, name }">
  <input
    v-model="state.email"
    :name="name"
    v-bind="methods"
  />
  <NotMessage :name="name" />
</NotField>
```

**Slot props:**
- `methods` - Event handlers for validation (onBlur, onChange, etc.)
- `name` - The field name (useful for labels and accessibility) <!---[`more`](/api/use-not-field)-->

### NotMessage Component

`NotMessage` automatically displays validation errors for a field:

```vue
<NotMessage :name="name" />
```

It shows error messages when validation fails and hides them when the field is valid.

## Validation Timing

By default, :name-text validates fields:
- **On blur** - When a field loses focus
- **On submit** - When the form is submitted

You can customize this behavior (more on this in advanced usage).

## Working with Different Input Types

:name-text works with any HTML input element:

### Text Inputs

```vue
<NotField name="username" v-slot="{ methods, name }">
  <input
    v-model="state.username"
    type="text"
    :name="name"
    v-bind="methods"
    placeholder="Enter username"
  />
  <NotMessage :name="name" />
</NotField>
```

### Textareas

```vue
<NotField name="bio" v-slot="{ methods, name }">
  <textarea
    v-model="state.bio"
    :name="name"
    v-bind="methods"
    rows="4"
  />
  <NotMessage :name="name" />
</NotField>
```

### Checkboxes

```vue
<NotField name="agree" v-slot="{ methods, name }">
  <label>
    <input
      v-model="state.agree"
      type="checkbox"
      :name="name"
      v-bind="methods"
    />
    I agree to the terms
  </label>
  <NotMessage :name="name" />
</NotField>
```

### Select Dropdowns

```vue
<NotField name="country" v-slot="{ methods, name }">
  <select
    v-model="state.country"
    :name="name"
    v-bind="methods"
  >
    <option value="">Select a country</option>
    <option value="us">United States</option>
    <option value="uk">United Kingdom</option>
    <option value="ca">Canada</option>
  </select>
  <NotMessage :name="name" />
</NotField>
```

## Complete Example

Here's a more comprehensive registration form:

::code-collapse
```vue [RegistrationForm.vue]
<script setup lang="ts">
import { useNotForm, NotForm, NotField, NotMessage } from 'notform'
import { z } from 'zod'

const { state, id, submit } = useNotForm({
  schema: z.object({
    username: z.string().min(3, 'Username must be at least 3 characters'),
    email: z.string().email('Invalid email address'),
    password: z.string().min(8, 'Password must be at least 8 characters'),
    confirmPassword: z.string(),
    country: z.string().min(1, 'Please select a country'),
    agree: z.boolean().refine(val => val === true, 'You must agree to continue')
  }).refine(data => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ['confirmPassword']
  }),
  onSubmit: async (data) => {
    console.log('Registration data:', data)
    // Handle registration logic
  }
})
</script>

<template>
  <NotForm :id="id" @submit="submit">
    <NotField name="username" v-slot="{ methods, name }">
      <label :for="name">
        Username
        <input
          v-model="state.username"
          type="text"
          :id="name"
          :name="name"
          v-bind="methods"
        />
        <NotMessage :name="name" />
      </label>
    </NotField>

    <NotField name="email" v-slot="{ methods, name }">
      <label :for="name">
        Email
        <input
          v-model="state.email"
          type="email"
          :id="name"
          :name="name"
          v-bind="methods"
        />
        <NotMessage :name="name" />
      </label>
    </NotField>

    <NotField name="password" v-slot="{ methods, name }">
      <label :for="name">
        Password
        <input
          v-model="state.password"
          type="password"
          :id="name"
          :name="name"
          v-bind="methods"
        />
        <NotMessage :name="name" />
      </label>
    </NotField>

    <NotField name="confirmPassword" v-slot="{ methods, name }">
      <label :for="name">
        Confirm Password
        <input
          v-model="state.confirmPassword"
          type="password"
          :id="name"
          :name="name"
          v-bind="methods"
        />
        <NotMessage :name="name" />
      </label>
    </NotField>

    <NotField name="country" v-slot="{ methods, name }">
      <label :for="name">
        Country
        <select
          v-model="state.country"
          :id="name"
          :name="name"
          v-bind="methods"
        >
          <option value="">Select a country</option>
          <option value="us">United States</option>
          <option value="uk">United Kingdom</option>
          <option value="ca">Canada</option>
        </select>
        <NotMessage :name="name" />
      </label>
    </NotField>

    <NotField name="agree" v-slot="{ methods, name }">
      <label>
        <input
          v-model="state.agree"
          type="checkbox"
          :name="name"
          v-bind="methods"
        />
        I agree to the terms and conditions
      </label>
      <NotMessage :name="name" />
    </NotField>

    <button type="submit">Register</button>
  </NotForm>
</template>
```
::

## Form State

The `state` object is reactive and automatically typed based on your schema:

```ts
const { state } = useNotForm({
  schema: z.object({
    name: z.string(),
    age: z.number()
  })
})

// state.name is typed as string
// state.age is typed as number

// You can access values anywhere in your component
console.log(state.name)
console.log(state.age)
```

## Validation Messages

Customize error messages directly in your schema:

```ts
z.object({
  email: z.string().email('Please enter a valid email address'),
  password: z
    .string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')
})
```

## Next Steps

Now that you understand the basics, explore more advanced features:

<!-- - [**Array Fields**](/guides/array-fields) - Handle dynamic lists and nested forms-->
<!-- - [**Custom Validation**](/guides/custom-validation) - Write custom validation rules-->
<!-- - [**Async Validation**](/guides/async-validation) - Validate against your API-->
<!-- - [**Form State Management**](/guides/form-state) - Track dirty, touched, and submitting states-->
<!-- - [**API Reference**](/api/use-not-form) - Complete API documentation -->

::tip
**Building complex forms?** Check out the `NotArrayField` component for handling dynamic lists of fields.
::