---
title: Introduction
description: A standard-schema based Vue form validator designed to make form validation as easy and painless as possible.
navigation:
  icon: i-tabler-home
---

## Why NotForm?

:name-text is a standard-schema based Vue form validator designed to simplify form validation while preserving the natural "Vue way" of doing things. It provides a single composable and renderless components that give you everything needed to validate your forms with confidence.

It also includes an array field component that eliminates the complexity of handling dynamic array fields in your forms.

## What Makes NotForm Special?

:name-text isn't just another form library. It's built with specific principles that make form validation in Vue applications feel natural and intuitive.

### Type-Safe from the Ground Up

:name-text is written in TypeScript and leverages your validation schema to provide complete type safety throughout your forms. Get intelligent autocomplete suggestions, catch errors at compile time, and enjoy a superior developer experience with full IDE support.

Your schema becomes the single source of truth for both runtime validation and compile-time type checking.

### Built with Composition API

:name-text is designed specifically for Vue 3, NotForm embraces the Composition API to give you maximum flexibility and composability. Use the `useNotForm` composable alongside your other composables for a consistent, modern Vue development experience.

### Completely UI Agnostic

:name-text doesn't impose any styling or UI opinions on your application. Use it with [Nuxt UI](https://ui.nuxt.com), [ShadcnVue](https://www.shadcn-vue.com/), [Vuetify](https://vuetifyjs.com/), [PrimeVue](https://primevue.org/), or build your own custom components from scratch.

The components are renderless and headless—they manage state and validation logic while giving you complete control over presentation and styling. Your UI library's components work exactly as they should.

### Framework Agnostic Validation

:name-text works with any standard-schema compatible validation library:

- [**Zod**](https://zod.dev/) - TypeScript-first schema validation
- [**Valibot**](https://valibot.dev/) - Modular and type-safe validation
- [**Yup**](https://github.com/jquense/yup) - Dead simple object schema validation
- [**ArkType**](https://arktype.io/) - TypeScript's 1:1 validator
- Any library that implements the standard-schema interface

Define your schema once and let NotForm handle the rest.

## Key Features

- [**Schema-Based Validation**]{class="text-primary"}: Use Zod, Yup, Valibot, or ArkType for powerful, type-safe validation
- [**Field-Level Control**]{class="text-primary"}: Validate on blur, change, submit, or programmatically—you decide
- [**Array Field Support**]{class="text-primary"}: Built-in support for dynamic form arrays with add, remove, and nested validation
- [**Error Management**]{class="text-primary"}: Automatic error tracking and display with customizable error messages
- [**Form State**]{class="text-primary"}: Track dirty, touched, valid, submitting states for better UX
- [**Async Validation**]{class="text-primary"}: Support for async validation rules and server-side validation
- [**Type Safety**]{class="text-primary"}: Full TypeScript support with inferred types from your schema
- [**Accessible**]{class="text-primary"}: Built with accessibility in mind for inclusive form experiences

## Quick Example

Here's how simple it is to create a validated form with NotForm:

```vue [form.vue]
<script setup lang="ts">
import { useNotForm, NotForm, NotField, NotMessage } from 'notform'
import { z } from 'zod'

const { state, id, submit } = useNotForm({
  schema: z.object({
    email: z.string().email('Please enter a valid email'),
    password: z.string().min(8, 'Password must be at least 8 characters')
  }),
  onSubmit: async (data) => {
    // Your custom submission logic here
    console.log('Validated data:', data)
  }
})
</script>

<template>
  <NotForm :id="id" @submit="submit">
    <NotField name="email" v-slot="{ methods, name }">
        <label :for="name">
          Email
          <input
            v-model="state.email"
            type="email"
            :id="name"
            :name="name"
            v-bind="methods"
          />
          <NotMessage :name="name" />
        </label>
    </NotField>

    <NotField name="password" v-slot="{ methods, name }">
        <label :for="name">
          Password
          <input
            v-model="state.password"
            type="password"
            :id="name"
            :name="name"
            v-bind="methods"
          />
          <NotMessage :name="name" />
        </label>
    </NotField>

    <button type="submit">Submit</button>
  </NotForm>
</template>
```

## What's Next?

Ready to get started? Head over to the [Installation](/getting-started/installation) guide to add NotForm to your project, or explore the [API Reference](/composables/use-not-form) to see everything NotForm can do.
